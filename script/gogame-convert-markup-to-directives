#!/usr/bin/env perl
use GoGameTools::features;
use GoGameTools::Util;
use GoGameTools::Plumbing;
use GoGameTools::TagHandler;
my %opt = get_options(
    expect_stdin => 1,
);
register_tags();
pipe_cat_map(pipe_convert_markup_to_directives());

=pod

=head1 NAME

gogame-convert-markup-to-directives - convert certain node markup to directives

=head1 SYNOPSIS

    $ ls *.sgf | gogame-convert-markup-to-directives

    $ gogame-convert-markup-to-directives --man

=head1 DESCRIPTION

Expects on STDIN either an SGJ collection or a list of file names from which
the SGJ is read.

Traverses each node of the given SGF trees. For each node, certain markup is
converted to directives. This makes it possible enter problem trees using
markup that is supported by most SGF editors.

Common directives can be authored using standard SGF properties. For example,
instead of C<{{ bad_move }}>, you can just use C<BM[]>. This isn't useful for
all directives, especially not those taking an argument like C<{{ answer ...
}}> or C<{{ condition ... }}>. It's just intended as an easier way to author
problems.

Usually the result of this program is piped to C<gogame-gen-problems>.

The following command-line options are supported:

=over 4

=item C<--verbose>, C<-v>

Logs additional informatino on STDERR.

=item C<--help>, C<-h>

Prints the synopsis.

=item C<--man>

Prints the whole documentation.

=item C<--version>

Prints the program version.

=back

The following section describes which markup is converted to which directive.

=over 4

=item *

a cross on the node's move becomes C<{{ bad_move }}>

Mnemonic: "not here".

=item *

a cross on an empty intersection becomes C<{{ barrier }}>

=item *

a square on the node's move becomes C<{{ good_move }}>

=item *

a square on an empty intersection becomes C<{{ correct }}>

Mnemonic: "Q.E.D." in proofs is accompanied by a square.

=item *

two squares, one on an empty intersection; the other on an opponent stone become C<{{ correct_for_both }}>

=item *

two squares on empty intersections become C<{{ assemble }}>

=item *

a circle on the node's move becomes C<{{ guide }}>

Mnemonic: "play here".

=item *

two circles on empty intersections become C<{{ has_all_good_responses }}>

=item *

C<HO[1]> ("hotspot") also becomes C<{{ barrier }}>.

SGF editors like SmartGo and Sabaki highlight hotspots in the game tree, so
using this property makes it easy to see barriers.

=back

So you can combine the markup for C<{{ good_move }}> and C<{{ assemble }}>, for
example; also C<{{ has_all_good_responses }}> and C<{{ guide }}>, These
combinations could occur.

Other markup such as crosses, squares and circles on intersections not covered
by the above input rules, as well as triangles, labels and numbers, remains
unchanged.
